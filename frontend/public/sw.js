// Vigor PWA Service Worker
// Provides offline functionality, background sync, and push notifications

import { Queue } from 'workbox-background-sync';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

// PWA Configuration
const CACHE_NAME = 'vigor-pwa-v1';
const API_CACHE_NAME = 'vigor-api-v1';
const WORKOUT_CACHE_NAME = 'vigor-workouts-v1';
const OFFLINE_PAGE = '/offline.html';

// Precache static assets generated by build process
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Cache strategies for different content types

// 1. App Shell - Cache First (static app resources)
registerRoute(
  ({ request }) => request.destination === 'document',
  new StaleWhileRevalidate({
    cacheName: 'vigor-pages',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          // Normalize URLs for consistent caching
          const url = new URL(request.url);
          // Remove query parameters for app routes
          if (url.pathname.startsWith('/app')) {
            return url.pathname;
          }
          return request.url;
        },
      },
    ],
  })
);

// 2. Static Assets - Cache First with long-term caching
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new CacheFirst({
    cacheName: 'vigor-static-assets',
    plugins: [
      {
        cacheExpiration: {
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        },
      },
    ],
  })
);

// 3. Images and Icons - Cache First
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'vigor-images',
    plugins: [
      {
        cacheExpiration: {
          maxEntries: 100,
          maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        },
      },
    ],
  })
);

// 4. API Calls - Network First with fallback
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: API_CACHE_NAME,
    networkTimeoutSeconds: 10,
    plugins: [
      {
        cacheExpiration: {
          maxEntries: 50,
          maxAgeSeconds: 60 * 60, // 1 hour
        },
      },
      {
        cacheWillUpdate: async ({ response }) => {
          // Only cache successful responses
          return response.status === 200;
        },
      },
    ],
  })
);

// 5. Workout Data - Special handling for offline capability
registerRoute(
  ({ url }) => url.pathname.includes('/workouts/') || url.pathname.includes('/ai/'),
  new NetworkFirst({
    cacheName: WORKOUT_CACHE_NAME,
    networkTimeoutSeconds: 15,
    plugins: [
      {
        cacheExpiration: {
          maxEntries: 30,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    ],
  })
);

// Background Sync for offline workout logging
const workoutQueue = new Queue('workout-logs', {
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        const response = await fetch(entry.request);
        if (!response.ok) {
          throw new Error(`Failed to sync workout log: ${response.status}`);
        }
        console.log('✅ Workout log synced successfully');

        // Notify user of successful sync
        self.registration.showNotification('Workout Synced! 💪', {
          body: 'Your workout has been saved successfully.',
          icon: '/icons/vigor-icon-192x192.png',
          badge: '/icons/vigor-badge-72x72.png',
          tag: 'workout-sync',
          silent: false,
        });
      } catch (error) {
        console.error('❌ Failed to sync workout log:', error);
        // Re-add to queue for retry
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Intercept workout log requests for background sync
registerRoute(
  ({ url, request }) =>
    url.pathname === '/api/workouts/logs' && request.method === 'POST',
  async ({ event }) => {
    try {
      const response = await fetch(event.request.clone());
      return response;
    } catch (error) {
      // Add to background sync queue if offline
      await workoutQueue.pushRequest({ request: event.request });

      // Return a custom response indicating the request is queued
      return new Response(
        JSON.stringify({
          success: true,
          queued: true,
          message: 'Workout logged offline. Will sync when connection is restored.',
        }),
        {
          status: 202,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }
  }
);

// Push Notifications Handler
self.addEventListener('push', (event) => {
  if (!event.data) {
    return;
  }

  const data = event.data.json();
  const options = {
    body: data.body || 'Stay consistent with your fitness journey!',
    icon: '/icons/vigor-icon-192x192.png',
    badge: '/icons/vigor-badge-72x72.png',
    image: data.image,
    tag: data.tag || 'vigor-notification',
    requireInteraction: false,
    silent: false,
    timestamp: Date.now(),
    actions: [
      {
        action: 'start-workout',
        title: 'Start Workout 💪',
        icon: '/icons/action-workout.png',
      },
      {
        action: 'open-app',
        title: 'Open Vigor',
        icon: '/icons/action-open.png',
      },
    ],
    data: {
      url: data.url || '/app/dashboard',
      ...data,
    },
  };

  event.waitUntil(
    self.registration.showNotification(data.title || 'Vigor Fitness', options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const { action, data } = event;

  let targetUrl = data?.url || '/app/dashboard';

  // Handle different notification actions
  switch (action) {
    case 'start-workout':
      targetUrl = '/workouts/generate';
      break;
    case 'open-app':
      targetUrl = '/app/dashboard';
      break;
    default:
      targetUrl = data?.url || '/app/dashboard';
  }

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clients) => {
      // Check if app is already open
      const existingClient = clients.find(
        (client) => client.url.includes(self.location.origin) && 'focus' in client
      );

      if (existingClient) {
        // Focus existing window and navigate to target
        existingClient.focus();
        existingClient.postMessage({
          type: 'NAVIGATE',
          url: targetUrl,
        });
      } else {
        // Open new window
        self.clients.openWindow(targetUrl);
      }
    })
  );
});

// Handle background sync events
self.addEventListener('sync', (event) => {
  if (event.tag === 'workout-sync') {
    event.waitUntil(workoutQueue.replayRequests());
  }
});

// Offline fallback page
self.addEventListener('fetch', (event) => {
  // Handle navigation requests that fail
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(OFFLINE_PAGE);
      })
    );
  }
});

// Install and activate events
self.addEventListener('install', (event) => {
  console.log('🔧 Vigor Service Worker installing...');

  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([
        '/',
        '/app/dashboard',
        '/workouts/generate',
        '/coach',
        '/offline.html',
        '/icons/vigor-icon-192x192.png',
      ]);
    })
  );

  // Take control immediately
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('✅ Vigor Service Worker activated');

  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((cacheName) => {
              return cacheName !== CACHE_NAME &&
                     cacheName !== API_CACHE_NAME &&
                     cacheName !== WORKOUT_CACHE_NAME;
            })
            .map((cacheName) => caches.delete(cacheName))
        );
      }),
      // Take control of all clients
      self.clients.claim(),
    ])
  );
});

// Handle messages from the main thread
self.addEventListener('message', (event) => {
  const { type, data } = event.data;

  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
    case 'CACHE_WORKOUT':
      // Cache a specific workout for offline access
      event.waitUntil(
        caches.open(WORKOUT_CACHE_NAME).then((cache) => {
          return cache.put(`/api/workouts/${data.workoutId}`, new Response(JSON.stringify(data.workout)));
        })
      );
      break;
    case 'GET_CACHED_WORKOUTS':
      // Return cached workouts for offline mode
      event.waitUntil(
        caches.open(WORKOUT_CACHE_NAME).then(async (cache) => {
          const keys = await cache.keys();
          const workouts = await Promise.all(
            keys.map(async (request) => {
              const response = await cache.match(request);
              return response ? response.json() : null;
            })
          );

          event.ports[0].postMessage({
            type: 'CACHED_WORKOUTS',
            data: workouts.filter(Boolean),
          });
        })
      );
      break;
  }
});

console.log('🚀 Vigor PWA Service Worker loaded successfully!');
