# Branch Management Strategy

## Current Branch Issues

We currently have multiple branches that are causing management complexity:

- Feature branches (fix-cicd-issues-\*)
- Dependabot branches
- Manual branches (update-metadata)

## Simplified Branch Strategy

We'll implement a balanced branch management approach that provides adequate protection without excessive complexity:

### Core Branches

1. **main** - Production code

   - Protected branch with strict rules
   - Deployments go directly from this branch
   - No direct commits allowed

2. **develop** - Integration branch
   - Where features are integrated before going to main
   - Semi-protected with lighter rules
   - Deployments to testing environments

### Temporary Branches

3. **feature/** - For new features or bug fixes

   - Created from and merged back to develop
   - Short-lived (days to weeks)
   - Naming: `feature/brief-description`

4. **hotfix/** - For urgent production fixes
   - Created from main, merged to both main and develop
   - Very short-lived (hours to days)
   - Naming: `hotfix/brief-description`

### Automation Branches

5. **dependabot/** - Generated by Dependabot
   - Automatically created for dependency updates
   - Merged to develop after review

## Branch Protection Rules

### For main branch:

- Require pull request reviews before merging
- Require status checks to pass
- Require branches to be up to date
- No direct pushes (even by admins)

### For develop branch:

- Require status checks to pass
- Allow administrators to bypass

## Pull Request Process

1. Create feature/hotfix branch
2. Develop and test changes
3. Create PR to appropriate target (develop or main)
4. Pass automated checks
5. Get required reviews
6. Merge using squash merge

## Implementation Plan

1. Create develop branch (if it doesn't exist)
2. Update branch protection rules
3. Consolidate existing feature branches
4. Clean up stale branches
5. Document process for the team
